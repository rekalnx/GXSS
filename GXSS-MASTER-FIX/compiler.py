import os
import glob

# === GRANDMASTER CONFIGURATION ===
PAYLOAD_DIR = "payload"
OUTPUT_FILE = "payloads.go"

# Context & Priority Mapping
# Priority: Higher number = Higher priority (Executed first)
CONTEXT_MAP = {
    "xss-abraham.txt":     {"ctx": "POLYGLOT_CONTEXT", "prio": 100},
    "xsspollygots.txt":      {"ctx": "WAF_BYPASS_CONTEXT", "prio": 90},
    "xsswafbypss.txt":      {"ctx": "WAF_BYPASS_CONTEXT", "prio": 85},
    "xss-js.txt":           {"ctx": "JAVASCRIPT_CONTEXT", "prio": 80},
    "xss-dalfox.txt":       {"ctx": "ATTRIBUTE_CONTEXT", "prio": 70},
    "xss-jsonp.txt":        {"ctx": "JSONP_CONTEXT", "prio": 60},
    "xss-owasp-real.txt":   {"ctx": "HTML_CONTEXT", "prio": 50},
    "xss-master.txt":       {"ctx": "HTML_CONTEXT", "prio": 40},
    "xss.txt":              {"ctx": "HTML_CONTEXT", "prio": 30},
    "xsswafbypss-2.txt":      {"ctx": "WAF_BYPASS_CONTEXT", "prio": 20},
    "tino-xss.txt":      {"ctx": "WAF_BYPASS_CONTEXT", "prio": 15},
    "abraham-xss.txt":      {"ctx": "WAF_BYPASS_CONTEXT", "prio": 10},    
    "default":              {"ctx": "HTML_CONTEXT", "prio": 5}
}

HEADER = """package main

// AUTO-GENERATED BY GXSS GRANDMASTER COMPILER
// OPTIMIZED FOR HIGH-PRIORITY EXECUTION

type PayloadContext int

const (
        HTML_CONTEXT PayloadContext = iota
        ATTRIBUTE_CONTEXT
        JAVASCRIPT_CONTEXT
        URL_CONTEXT
        JSON_CONTEXT
        TAG_CONTEXT
        EVENT_HANDLER_CONTEXT
        POLYGLOT_CONTEXT
        WAF_BYPASS_CONTEXT
        JSONP_CONTEXT
)

type ContextualPayloadSet struct {
        Context  PayloadContext
        Payloads []string
        Priority int
}

var PayloadDatabase = []ContextualPayloadSet{
"""

FOOTER = """}

func GetPayloadsByContext(ctx PayloadContext) []string {
        var payloads []string
        // Logic: Payloads are already sorted by priority during compilation
        for _, set := range PayloadDatabase {
                if set.Context == ctx {
                        payloads = append(payloads, set.Payloads...)
                }
        }
        return payloads
}

func GetAllPayloads() []string {
        var all []string
        for _, set := range PayloadDatabase {
                all = append(all, set.Payloads...)
        }
        return all
}
"""

def escape_go_string(s):
    if "`" in s:
        return '`' + s.replace("`", '` + "`" + `') + '`'
    return '`' + s + '`'

def compile_payloads():
    if not os.path.exists(PAYLOAD_DIR):
        print(f"[!] Error: Folder '{PAYLOAD_DIR}' not found.")
        return

    print("[*] Starting Grandmaster Compilation...")
    
    # Store data: list of dicts {context, priority, payloads}
    raw_data = []
    
    files = glob.glob(os.path.join(PAYLOAD_DIR, "*.txt"))
    
    for filepath in files:
        filename = os.path.basename(filepath)
        config = CONTEXT_MAP.get(filename, CONTEXT_MAP["default"])
        context_name = config["ctx"]
        priority = config["prio"]
        
        print(f"    -> Ingesting {filename} [{context_name}] (Priority: {priority})")
        
        try:
            with open(filepath, "r", encoding="utf-8", errors="ignore") as f:
                lines = [l.strip() for l in f.readlines() if l.strip()]
                # Deduplicate within file
                unique_lines = list(dict.fromkeys(lines))
                
                raw_data.append({
                    "ctx": context_name,
                    "prio": priority,
                    "payloads": unique_lines
                })
                
        except Exception as e:
            print(f"[!] Failed to read {filename}: {e}")

    # Sort by Priority Descending (Highest first)
    raw_data.sort(key=lambda x: x["prio"], reverse=True)

    # Write to Go file
    with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
        out.write(HEADER)
        
        count = 0
        for entry in raw_data:
            out.write("\t{\n")
            out.write(f"\t\tContext:  {entry['ctx']},\n")
            out.write(f"\t\tPriority: {entry['prio']},\n")
            out.write("\t\tPayloads: []string{\n")
            
            for p in entry['payloads']:
                out.write(f"\t\t\t{escape_go_string(p)},\n")
                count += 1
                    
            out.write("\t\t},\n")
            out.write("\t},\n")
            
        out.write(FOOTER)
    
    print(f"\n[SUCCESS] Compiled {count} high-performance payloads into '{OUTPUT_FILE}'.")

if __name__ == "__main__":
    compile_payloads()
